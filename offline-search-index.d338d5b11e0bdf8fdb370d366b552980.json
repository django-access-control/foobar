[{"body":"The theory  Experience by itself teaches nothing...\nWithout theory, experience has no meaning.\nWithout theory, one has no questions to ask.\nHence without theory there is no learning.\n~ W. Edwards Deming  Yes, theories can be boring. However, we need to establish some common vocabulary before we can move forward. Therefore, please review the theory section before heading on to practical stuff.\nInstallation pip install django-access-control That‚Äôs it. No need to add anything to INSTALLED_APPS, configure the AUTHENTICATION_BACKENDS or inherit from our User model. Also, we do not create any objects in your database.\nImplementing access control Different systems need different granularity when it comes to access control. Let‚Äôs go over some examples moving from more broad categories to more specific ones.\nWe will implement a simplified version of the example project: a Q\u0026A site. Let‚Äôs create the model Question as follows:\nfrom django.db import models class Question(models.Model): title = models.CharField(max_length=100) body = models.TextField() author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.PROTECT) is_published = models.BooleanField(default=True) objects = QuestionQuerySet.as_manager() def __str__(self) -\u003e str: return self.title Above the model, let‚Äôs add the query set:\nfrom django_access_control.querysets import ConfidentialQuerySet class QuestionQuerySet(ConfidentialQuerySet): pass Finally, let‚Äôs register oue model to the DJango admin site:\nfrom django.contrib import admin from django_access_control.admin import ConfidentialModelAdmin from questions.models import Question @admin.register(Question) class QuestionAdmin(ConfidentialModelAdmin): def save_model(self, request, obj, form, change): \"\"\" Automatically fill `question.author` with the current user when a new question is added. \"\"\" if not change: # `not change` means the obj is added, not modified obj.author = request.user super().save_model(request, obj, form, change) Now everything should work in the same way as it normal would since our permission policy defaults are the same as Django‚Äôs to make it more intuitive to use.\nTable level permissions There are four methods to configure table level permissions. Here they are with their default implementations:\ndef has_table_wide_add_permission(self, user: AbstractUser) -\u003e bool: return user.is_superuser or has_permission(user, \"add\", self.model) def has_table_wide_view_permission(self, user: AbstractUser) -\u003e bool: return user.is_superuser or has_permission(user, \"view\", self.model) def has_table_wide_change_permission(self, user: AbstractUser) -\u003e bool: return user.is_superuser or has_permission(user, \"change\", self.model) def has_table_wide_delete_permission(self, user: AbstractUser) -\u003e bool: return user.is_superuser or has_permission(user, \"delete\", self.model) Let‚Äôs override one of them to give every logged in user the right to add questions:\ndef has_table_wide_add_permission(self, user: AbstractUser) -\u003e bool: return user.is_authenticated Row level permissions If the user has some permission for the entire table, it will apply to all the rows. The methods below will give you more granular control by allowing to you give extra permission to a limited number or rows.\nThe methods you can use are:\ndef rows_with_extra_view_permission(self, user: AbstractUser) -\u003e QuerySet: return self.none() def rows_with_extra_change_permission(self, user: AbstractUser) -\u003e QuerySet: return self.none() def rows_with_extra_delete_permission(self, user: AbstractUser) -\u003e QuerySet: return self.none() By default they do not grant permission to any rows. Let‚Äôs adjust the view permissions so that\n everybody can see published questions staff members can see all questions authors can see their questions even if they are not published  def rows_with_extra_view_permission(self, user: AbstractUser) -\u003e QuerySet[Question]: if user.is_staff: return self return self.filter(is_published=True) | \\ (self.filter(author=user) if user.is_authenticated else self.none()) On the last line | is the bitwise OR operator which returns the union of the two querysets (this is why we learned set theory at school üôÇ ).\nThe if user.is_authenticated else is necessary because if the user is not logged in, they are represented by an AnonymousUser which has a more limited interface compared to the regular User. Without this check, AnonymousUser would be passed to self.filter(author=user) which would result in an exception in the lower layers (which was pretty hard to track down‚Ä¶).\nBe mindful! There are two methods with very similar names:\n rows_with_extra_view_permission rows_with_view_permission  You should override the first one. The later on will use rows_with_extra_view_permission as well as has_table_wide_view_permission to combine together all the rows the user can view. That method might be handy if you need to fetch all the rows in your view layer. It is also internally used in the Django admin integration.\n Colum level permissions There are three methods for fine-tuning field level permissions:\n@classmethod def addable_fields(cls, user: AbstractUser) -\u003e FrozenSet[str]: \"\"\" Control which fields the user can specify when creating a new object (row). NB! Make sure that all not nullable fields that are not specified here would be populated automatically to prevent IntegrityError for the database. \"\"\" return frozenset(all_field_names(cls.model)) @staticmethod def viewable_fields(user: AbstractUser, obj) -\u003e FrozenSet[str]: \"\"\" Control which wields the user can view. \"\"\" return frozenset(all_field_names(obj)) @staticmethod def changeable_fields(user: AbstractUser, obj) -\u003e FrozenSet[str]: \"\"\" Control which wields the user can edit. \"\"\" return frozenset(all_field_names(obj)) By default the user has access to all the fields. Let‚Äôs update it so that\n the question authors can update the body of the question stuff members can publish and unpublish questions superusers can do everything  @staticmethod def changeable_fields(user: AbstractUser, obj: Question) -\u003e FrozenSet[str]: if user.is_superuser: return frozenset(all_field_names(obj)) fields = frozenset() if obj.author == user: fields |= frozenset({\"body\"}) if user.is_staff: fields |= frozenset({\"is_published\"}) return fields  We use frozenset ‚Äì an immutable version of the regular set ‚Äì because immutability greatly reduces the risk of human error (such as passing the mutable set to a function as an argument, modifying it in the function and not being aware that the changes will also influence other places where the same set is used). And mistakes in the security layer can be costly‚Ä¶  The view layer Django Access Control provides out-of-the-box integration with the Django admin site through the ConfidentialModelAdmin class. You can use its implementation as an example for your custom views and forms as well.\nIn addition to the methods already discussed above, ConfidentialQuerySet provides some special methods intended to be used in the view layer:\n rows_with_view_permission(self, user: AbstractUser) -\u003e QuerySet rows_with_change_permission(self, user: AbstractUser) -\u003e QuerySet rows_with_delete_permission(self, user: AbstractUser) -\u003e QuerySet rows_with_some_permission(self, user: AbstractUser) -\u003e QuerySet ‚Äì returns all rows for which the user has at least some kind of permissions has_some_permissions(self, user: AbstractUser) -\u003e bool ‚Äì indicates whether the user has any permission to any instance of the model contains(self, obj: Model) -\u003e bool ‚Äì indicates whether the given queryset contains the obj  Django Access Control cannot guard you from everything.\nPlease refer to the security notice for further details.  ","excerpt":"The theory  Experience by itself teaches nothing...\nWithout theory, ‚Ä¶","ref":"/docs/userguide/","title":"User guide"},{"body":"What are permissions A permission consists of an action and an object. E.g. ‚Äúcan view (action) question with ID 5 (object).\"\nPermissions are hierarchical: their object can be\n an entire database table (a Django model), e.g. ‚Äúcan view all questions‚Äù. a specific row (an instance of a Django model), e.g. ‚Äúcan view all question with ID 5‚Äù. a specific field of a specific row (a field of an instance of a Django model), e.g. ‚Äúcan view the title of the question with ID 5‚Äù.  If one has the permission ‚Äúcan view all questions‚Äù, they implicitly also have ‚Äúcan view all question with ID 5‚Äù and ‚Äúcan view the title of the question with ID 5‚Äù.\nWe refer to this as the scope of the permission.\nCurrently we support the same four permission actions as Django natively does:\n add view change delete  Some actions are restricted to a specific scope. For instance, you can have the permission ‚Äúcan add a question‚Äù (with table scope), but ‚Äúcan add a question with ID 5‚Äù would make no sense given that such a question already exists. Likewise, the ‚Äúdelete‚Äù permission can be granted for all rows in a table or for a specific row, but not for a field (updating the value of a field to be None/null would not quality as deleting it).\n    table/model row/object field     add X - X   delete X X -   view X X X   change X X X    Access control system in software layers A good software system consists of distinct layers. Although the layers themselves are usually the same, each framewrok names them differently. In case of Django, they would be:\n Template Django admin   View   Business logic   Data access    #system-layers-diagram td { text-align: center; vertical-align: middle; }   the template layer (serializer layer in REST APIs) ‚Äì responsible for formating the response the user can see the view layer ‚Äì responsible for the content the user can see the service layer ‚Äì responsible for an individual unit of work which can be used by many views. In smaller projects it is OK to merge it with the view layer, but in bigger projects a distinct service layer makes it easier to reuse, decouple and test your code the data access layer ‚Äì responsible for retrieving and saving the data, in other words, responsible for communicating with the underlying database  The Django admin site combines the template and the view layers (although you do can dig in and modify both the underling templates and views for more granular customizations).\nIt is technically possible to implement the access control system in any of the layers. You can even put it into the template layer ‚Äì meaning that your security mechanisms live alongside your HTML tags ‚Äì but this lead to numerous problems regarding both code readability as well as security risks.\nThe deeper in the layer system the access control system is implemented, the fewer code duplication we need and the less likely it is that we accidentally forget to consider it in some database queries.\nThus, the access control system should be implemented in the data access layer, in Django terms, in the QuerySet.\nHow the access control is used in higher layers The basic idea is to have have special methods on the QuerySet which will figure out, which data the user can access. This method will be chained with other methods performing filtering based on which data we need to retrieve, e.g. Question.objects.rows_with_view_permission(user).filter(is_relevant=True).\nExplicit and implicit permissions Permissions can be granted explicitly or be deducted implicitly from existing data. E.g. in a StackOverflow style system you can update a question if\n you are an admin (the admin privileges have been explicitly granted to you) you are the one who asked the question (your ownership position implicitly grants you the permission) you have enough reputation (your high reputation implicitly grants you the permission)  Thus the access control methods in the QuerySet have the entire database at their disposal: they can check for entries in the dedicated permissions table(s) as well as look for other pieces of data to deduct permissions from.\n","excerpt":"What are permissions A permission consists of an action and an object. ‚Ä¶","ref":"/docs/theory/","title":"Theory"},{"body":"Here we have a simple forum site for questions about ethics. Beside the built in models like User it has only one model: the Question (and ‚Äì unfortunately ‚Äì no model for answers‚Ä¶).\nThere are three types of users with different sets of permissions:\n Anonymous users can view (but not edit) questions, which have is_published set to True. Logged in users can see published questions and also ask new ones. Later on they can edit the body of the question, but not its title. The author of the question can see it even if it is not published. Staff members have the additional privileges of also seeing unpublished questions and changing the question‚Äôs is_published value. It is True by default.  Installation and setup The source code can br found here.\nAssuming that you have a Unix-like shell, the setup is as follows:\ngit clone git@github.com:django-access-control/example-project.git cd example-project python3.9 -m venv venv . ./venv/bin/activate pip install -r requirements.txt mv db.sqlite3.example db.sqlite3 ./manage.py runserver An quick walk through The anonymous user‚Äôs point of view  Open http://127.0.0.1:8000/ in your browser. You should see the familiar Django admin interface.  Click on the blue text ‚ÄúQuestions‚Äù and you see the list view of all published questions.  Click on the first question and you will see a read-only detailed view.  The logged in user‚Äôs point of view  Click ‚ÄúLOG IN‚Äù in the upper right corner and enter the username Thomas_Aquinas and password: adminadmin. You will be directed back to the index page. Now the ‚Äú+ Add‚Äù button has appeared for ‚ÄúQuestions‚Äù.  Click again on the blue text ‚ÄúQuestions‚Äù and you will see the list view. That time, however, one more question has appeared: ‚ÄúWhat is virtue?‚Äù is not published, but since Thomas Aquinas (the logged in user) is the author of that question, they can still see it.  Clicking on the title of that question will open the change view where you can make adjustments to the body of the question.  Opening a question by some other author (e.g. ‚ÄúWhat makes somebody‚Äôs life meaningful?‚Äù will open a read-only view).  The staff member‚Äôs point of view Click ‚ÄúLOG OUT‚Äù in the upper right corner, click ‚ÄúLOG IN‚Äù and enter the username NƒÅgƒÅrjuna and password: adminadmin. Click on the blue text ‚ÄúQuestions‚Äù and then click on any of the questions in the list view. Now you see a checkbox to alter the ‚ÄúIs published‚Äù value.\nAnd what is the significance of this? The above screenshots do not look like something very special, do they? Any descent application should be able to do that, shouldn‚Äôt it?\nThe value lies in the way access control is implemented: not in the template layer among your HTML code, but in the data access layer, so that all the views, REST \u0026 GraphQL controllers, CLI commands and other parts of the app can all go through the very same security layer. All the security configuration lives in the QuestionQuerySet class and ‚Äì thanks to sensible default ‚Äì is no more than 34 lines long.\n","excerpt":"Here we have a simple forum site for questions about ethics. Beside ‚Ä¶","ref":"/docs/sample-project/","title":"The sample project"},{"body":"Even if you use Django Access Control, you need to pay attention to some things we cannot guard you against.\nFirstly, we provide the QuerySet methods for enforcing access control, but it is up to you to use them in your views. If you accidentally have return Question.objects.all() instead of return Question.objects.rows_with_view_permission(user), you bypass all the security checks.\nDjango admin integration Beware that:\n Field level permissions are not enforced for list view since the same fields need to be shown for all the rows. You need to enforce field level permissions in admin actions yourself: since they are functions defined by you, you are responsible for the security as well.  ","excerpt":"Even if you use Django Access Control, you need to pay attention to ‚Ä¶","ref":"/docs/security-notice/","title":"Notes on security"},{"body":"We consider a project to be active if the last commit to the repository is less than two years old.\nActively maintained projects  Django Scoped Permissions ‚Äì not very popular, but might have useful ideas django-role-permissions ‚Äì seems popular django-tabular-permissions ‚Äì provides a good visual overview of the permissions the user has serious-django-permissions ‚Äì provides central per-app permissions management django-admin-permissions  No longer maintained projects  Django Permissions ‚Äì last commit in 2015 Django Flexible Permissions ‚Äì last commit in 2015, has some useful material Django Finegraned Permissions ‚Äì last commit in 2013, perhaps something interesting here Django Global Permissions ‚Äì last commit in 2018, might be useful Django Improved Permissions ‚Äì repo is archived, but the documentation seems useful django-field-object-permissions ‚Äì last commit in 2017, implements object permissions based on the value of some field django-field-permissions ‚Äì last commit in 2016  ","excerpt":"We consider a project to be active if the last commit to the ‚Ä¶","ref":"/docs/similar-projects/","title":"Similar projects"},{"body":"1.0 - 2021-07-09 Changed  Enhance ConfidentialQuerySet API Enhance integration with DJango admin site  0.4 - 2021-06-24 Changed  Remove the need to use a custom authentication backend Enhance ConfidentialQuerySet API Enhance integration with DJango admin site  0.3 - 2021-06-24 Changed  Make access control hierarchical, introduce the idea of quantifiers Refactor access control logic out of the ModelAdmin class so that is could be used in other places as well  0.2 - 2021-06-24 Changed  Project was renamed from Django Granular Permissions to Django access Control  0.1 - 2021-06-23 Added  Added ConfidentialQuerySet which provides access control on the data access level Added ConfidentialModelAdmin which can use ConfidentialQuerySet methods to enforce access control in Django admin Added AuthenticationBackend to handle custom permissions  ","excerpt":"1.0 - 2021-07-09 Changed  Enhance ConfidentialQuerySet API Enhance ‚Ä¶","ref":"/docs/changelog/","title":"Changelog"},{"body":"Django Access Control is a flexible and developer friendly framework for managing table, row and field level permissions.\nRefer to the user guide to get started!\n","excerpt":"Django Access Control is a flexible and developer friendly framework ‚Ä¶","ref":"/docs/","title":"Welcome to Django Access Control! üéâüîí"},{"body":"window.location.replace(\"/docs/\")","excerpt":"window.location.replace(\"/docs/\")","ref":"/","title":" "},{"body":"","excerpt":"","ref":"/categories/","title":"Categories"},{"body":"","excerpt":"","ref":"/search/","title":"Search Results"},{"body":"","excerpt":"","ref":"/tags/","title":"Tags"}]